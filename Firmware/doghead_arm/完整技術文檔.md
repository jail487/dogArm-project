# DogHead 書法機械手臂 - 完整技術文檔

**版本**: v2.0  
**最後更新**: 2025-12-31  
**微控制器**: STM32F446RET6  
**開發板**: NUCLEO-F446RE  
**機構類型**: 平面五連桿機構  
**馬達類型**: Nidec 無刷直流馬達

---

# 目錄

1. [專案概述](#專案概述)
2. [硬體配置](#硬體配置)
   - [系統時鐘配置](#系統時鐘配置)
   - [GPIO 引腳配置](#gpio-引腳配置)
   - [馬達驅動系統配置](#馬達驅動系統配置)
   - [Timer 配置](#timer-配置)
3. [軟體架構](#軟體架構)
   - [控制流程圖](#控制流程圖)
   - [檔案結構](#檔案結構)
   - [模組說明](#模組說明)
4. [PID 前饋控制架構](#pid-前饋控制架構)
   - [控制器類別詳解](#控制器類別詳解)
   - [軌跡規劃器](#軌跡規劃器)
   - [控制循環實作](#控制循環實作)
5. [馬達驅動層](#馬達驅動層)
6. [參數調整指南](#參數調整指南)
7. [故障排除](#故障排除)
8. [安全與注意事項](#安全與注意事項)
9. [待實作功能](#待實作功能)
10. [參考資料](#參考資料)

---

# 1. 專案概述

DogHead 書法機械手臂是一個基於 STM32F446 的雙關節平面機械手臂控制系統，採用五連桿機構設計，搭配 Nidec 無刷直流馬達與編碼器實現高精度位置控制。

## 核心功能
- ✅ 雙馬達協同控制（13-Pin 與 8-Pin Nidec 馬達）
- ✅ 編碼器閉環回饋（100 PPR × 4 = 400 脈衝/圈）
- ✅ PID + 前饋控制（速度前饋 + 加速度前饋）
- ✅ 五連桿正逆運動學解算
- ✅ 軌跡規劃與速度平滑
- ✅ 虛擬圍籬安全保護
- ⚙️ 測試模式（直接轉速控制）

---

# 2. 硬體配置

## 2.1 系統時鐘配置

| 參數 | 設定值 |
|------|--------|
| 系統時鐘源 | HSI (內部振盪器) |
| PLL 輸入 | HSI 16MHz |
| PLL_M | 16 |
| PLL_N | 336 |
| PLL_P | 4 |
| **SYSCLK** | **84 MHz** |
| AHB 時鐘 | 84 MHz |
| APB1 時鐘 | 42 MHz |
| APB2 時鐘 | 84 MHz |

---

## 2.2 GPIO 引腳配置

### 系統與調試接口

| Pin | 功能 | 說明 |
|-----|------|------|
| PA13 | SWDIO | SWD 調試接口 - 數據線 |
| PA14 | SWCLK | SWD 調試接口 - 時鐘線 |
| PB3 | SWO | SWD 追蹤輸出 |
| PC13 | B1 (USER Button) | 板載用戶按鈕 (下降沿觸發中斷) |
| PA5 | LD2 (LED) | 板載綠色 LED (Output) |

### 通訊接口

| Pin | 功能 | 說明 |
|-----|------|------|
| PA2 | USART2_TX | 串口傳輸 (115200 baud) |
| PA3 | USART2_RX | 串口接收 (115200 baud) |

---

## 2.3 馬達驅動系統配置

### 關節 1 - 13-Pin 馬達 (型號: 24H702U030)

**控制模式**: 頻率控制 (Frequency Control)

| 功能 | Pin | Timer/GPIO | 說明 |
|------|-----|-----------|------|
| 速度控制 PWM | PA5 | TIM2_CH1 | STMP 引腳，產生頻率信號 (400 pulses/rev) |
| 方向控制 | PC2 | GPIO Output | DIR 引腳 (Low=CW, High=CCW) |
| 啟動控制 | PC1 | GPIO Output | START 引腳 (High=Enable, Low=Disable) |
| 編碼器 A 相 | PB6 | TIM4_CH1 | Encoder Mode (100 PPR) |
| 編碼器 B 相 | PB7 | TIM4_CH2 | Encoder Mode (100 PPR) |

**馬達參數**:
- 額定轉速: 3000 RPM
- 最大轉速: 6000 RPM
- 編碼器解析度: 100 PPR (x4 模式 = 400 pulses/rev)
- 減速比: **50:1** (需依實際機構調整)

**頻率計算公式**: 
```c
Freq (Hz) = RPM × 400 / 60
```

---

### 關節 2 - 8-Pin 馬達 (型號: 24H220Q231)

**控制模式**: PWM 佔空比控制 (Low Active)

| 功能 | Pin | Timer/GPIO | 說明 |
|------|-----|-----------|------|
| 速度控制 PWM | PB4 | TIM3_CH1 | Low Active (100% Duty = 停止, 0% Duty = 最快) |
| 方向控制 | PC5 | GPIO Output | DIR 引腳 (High=CW, Low=CCW) |
| 煞車控制 | PC4 | GPIO Output | BRAKE 引腳 (High=Run, Low=Brake) |
| 編碼器 A 相 | PA8 | TIM1_CH1 | Encoder Mode (100 PPR) |
| 編碼器 B 相 | PA9 | TIM1_CH2 | Encoder Mode (100 PPR) |

**馬達參數**:
- 額定轉速: 3150 RPM
- 最大轉速: 6300 RPM
- 編碼器解析度: 100 PPR (x4 模式 = 400 pulses/rev)
- 減速比: **30:1** (需依實際機構調整)

**速度計算公式**: 
```c
CCR = ARR × (1 - Speed_Ratio)  // Low Active 特性
```

---

## 2.4 Timer 配置

### TIM1 - 編碼器模式 (8-Pin 馬達)
- **模式**: Encoder Mode x4
- **通道**: CH1 (PA8), CH2 (PA9)
- **ARR**: 65535 (最大值)
- **用途**: 讀取關節 2 位置

### TIM2 - PWM 頻率產生 (13-Pin 馬達速度控制)
- **模式**: PWM Generation CH1
- **通道**: CH1 (PA5)
- **用途**: 產生動態頻率信號控制 13-Pin 馬達轉速

### TIM3 - PWM 佔空比控制 (8-Pin 馬達速度控制)
- **模式**: PWM Generation CH1
- **通道**: CH1 (PB4)
- **用途**: 產生 PWM 信號控制 8-Pin 馬達轉速 (Low Active)

### TIM4 - 編碼器模式 (13-Pin 馬達)
- **模式**: Encoder Mode x4
- **通道**: CH1 (PB6), CH2 (PB7)
- **ARR**: 65535 (最大值)
- **用途**: 讀取關節 1 位置

---

# 3. 軟體架構

## 3.1 控制流程圖

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  目標位置   │────>│ 運動學 IK   │────>│ 軌跡規劃器  │────>│ PID+前饋    │
│  (X, Y)     │     │  (角度)     │     │ (速度/加速) │     │  控制器     │
└─────────────┘     └─────────────┘     └─────────────┘     └──────┬──────┘
                                                                     │
                    ┌────────────────────────────────────────────────┘
                    ↓
            ┌───────────────┐     ┌─────────────┐     ┌─────────────┐
            │  馬達驅動層   │────>│  PWM/Freq   │────>│  Nidec馬達  │
            │  (RPM指令)    │     │  產生器     │     │   硬體      │
            └───────────────┘     └─────────────┘     └──────┬──────┘
                    ↑                                         │
                    │                                         │
            ┌───────┴───────┐     ┌─────────────┐            │
            │  編碼器讀取   │<────│  編碼器     │<───────────┘
            │  (角度反饋)   │     │   硬體      │
            └───────────────┘     └─────────────┘
```

---

## 3.2 檔案結構

```
doghead_arm/
├── Core/
│   ├── Inc/
│   │   ├── pid_controller.hpp         ← PID+前饋控制器類別
│   │   ├── nidec_motor_driver.h       ← 馬達底層驅動 API
│   │   ├── kinematics.hpp             ← 運動學解算器
│   │   ├── main.h                     ← 主程式標頭檔
│   │   └── mainpp.h                   ← C++ 橋接標頭檔
│   └── Src/
│       ├── main.c                     ← 主程式入口 (C)
│       ├── robot_arm_core.cpp         ← 主控制邏輯 (C++)
│       ├── nidec_motor_driver.c       ← 馬達驅動實作 (C)
│       ├── kinematics.cpp             ← 運動學實作 (C++)
│       └── stm32f4xx_it.c             ← 中斷服務程式
└── 完整技術文檔.md                     ← 本文檔
```

---

## 3.3 模組說明

### 主程式模組 (main.c)
```c
int main(void) {
    HAL_Init();                    // 硬體抽象層初始化
    SystemClock_Config();          // 時鐘設定
    MX_GPIO_Init();                // GPIO 初始化
    MX_USART2_UART_Init();         // UART 初始化
    MX_TIM1_Init();                // Timer 初始化
    MX_TIM2_Init();
    MX_TIM3_Init();
    MX_TIM4_Init();
    
    Robot_Init();                  // 機器人系統初始化 (C++ 函式)
    
    while (1) {
        Robot_Loop(0.01f);         // 主控制迴圈 (10ms 週期)
        HAL_Delay(10);
    }
}
```

### 馬達驅動模組 (nidec_motor_driver.c/h)
- `Motor_System_Config()` - 硬體初始化
- `Motor_Init()` - 馬達物件初始化
- `Motor_Update()` - 編碼器讀取與溢位處理
- `Motor_GetAngle()` - 取得關節角度（考慮減速比）
- `Motor_SetSpeed()` - 設定馬達轉速 (RPM)
- `Motor_Start()/Stop()` - 啟動/停止馬達

### 機器手臂核心模組 (robot_arm_core.cpp)
- `Robot_Init()` - 系統初始化
- `Robot_Loop()` - 主控制迴圈（PID + 前饋）
- `Robot_SetTargetPosition()` - 設定目標座標
- `Robot_SetTestMode()` - 切換測試模式

### PID 控制器模組 (pid_controller.hpp)
- `PositionController` 類別
- `update()` - PID + 前饋控制演算法

### 運動學模組 (kinematics.hpp/cpp)
- `FiveBarKinematics` 類別
- `solveIK()` - 逆運動學（座標 → 角度）
- `solveFK()` - 正運動學（角度 → 座標）

---

# 4. PID 前饋控制架構

## 4.1 控制器類別詳解

### PositionController (PID+前饋控制器)
**檔案位置**: `Core/Inc/pid_controller.hpp`

#### 構造函數參數
```cpp
PositionController(float kp, float ki, float kd, float kv, float ka, float max_rpm)
```

| 參數 | 說明 | 典型值 | 調整建議 |
|------|------|--------|----------|
| `kp` | 位置比例增益 | 5.0~10.0 | 增加可提升響應速度，但過大會震盪 |
| `ki` | 位置積分增益 | 0.1~0.5 | 消除穩態誤差，過大會超調 |
| `kd` | 位置微分增益 | 0.0~1.0 | 阻尼作用，減少震盪 |
| `kv` | 速度前饋增益 | 0.8~1.2 | 速度指令直接映射，**建議從1.0開始** |
| `ka` | 加速度前饋增益 | 0.05~0.3 | 補償慣量，**從小值開始慢慢增加** |
| `max_rpm` | 最大轉速限制 | 3000~6000 | 依馬達規格設定 |

#### 控制算法公式
```cpp
// PID 反饋部分 (處理位置誤差)
error = target_pos - current_pos
feedback_rpm = Kp*error + Ki*∫(error*dt) + Kd*d(error)/dt

// 前饋部分 (預測性補償)
ff_velocity_rpm = (target_vel / 360.0) * 60.0 * Kv
ff_acceleration_rpm = target_acc * Ka

// 最終輸出
output_rpm = feedback_rpm + ff_velocity_rpm + ff_acceleration_rpm
```

#### 實際配置範例
```cpp
// 關節 1 (13-Pin 馬達 - 24H702U030)
// 參數: Kp, Ki, Kd, Kv, Ka, max_rpm
PositionController joint1_pid(5.0f, 0.1f, 0.0f, 1.0f, 0.1f, 3000.0f);

// 關節 2 (8-Pin 馬達 - 24H220Q231)
PositionController joint2_pid(8.0f, 0.2f, 0.0f, 1.0f, 0.15f, 4000.0f);
```

---

## 4.2 軌跡規劃器

### TrajectoryPlanner 類別
**檔案位置**: `Core/Src/robot_arm_core.cpp` (內嵌類別)

#### 功能說明
- **輸入**: 當前目標角度 (Degree)
- **輸出**: 目標速度 (Deg/s) 和加速度 (Deg/s²)
- **方法**: 一階差分 + 低通濾波

#### 算法流程
```cpp
// 1. 計算原始速度 (差分)
raw_velocity = (current_target - prev_target) / dt

// 2. 速度限幅
if (raw_velocity > max_velocity) raw_velocity = max_velocity

// 3. 一階低通濾波 (平滑處理)
velocity = α * raw_velocity + (1-α) * prev_velocity

// 4. 計算加速度 (速度的差分)
acceleration = (velocity - prev_velocity) / dt
```

#### 可調參數
| 參數 | 位置 | 說明 | 調整建議 |
|------|------|------|----------|
| `alpha` | Line 48 | 濾波係數 (0~1) | 0.7=較敏感，0.3=較平滑 |
| `max_velocity` | 參數預設 | 最大速度限制 | 360 Deg/s (60 RPM) |
| `max_acceleration` | 參數預設 | 最大加速度限制 | 1800 Deg/s² |

#### 實體化
```cpp
TrajectoryPlanner traj_joint1;  // 關節 1 軌跡規劃器
TrajectoryPlanner traj_joint2;  // 關節 2 軌跡規劃器
```

---

## 4.3 控制循環實作

### Robot_Loop() 完整流程
**檔案位置**: `Core/Src/robot_arm_core.cpp`

```cpp
void Robot_Loop(float dt_seconds) {
    // === 步驟 A: 讀取編碼器反饋 ===
    Motor_Update(&motor_joint_13pin);  // 處理編碼器溢位
    Motor_Update(&motor_joint_8pin);
    float real_theta1 = Motor_GetAngle(&motor_joint_13pin);
    float real_theta2 = Motor_GetAngle(&motor_joint_8pin);
    
    // === 步驟 B: 運動學計算目標角度 (IK) ===
    if (ik_mode_enabled) {
        MotorAngles solution = kinematics.solveIK({target_x, target_y});
        if (solution.is_reachable) {
            target_angle1_deg = rad2deg(solution.theta1);
            target_angle2_deg = rad2deg(solution.theta2);
        }
    }
    
    // === 步驟 C: 安全檢查 (工作空間限制) ===
    Point2D current_pos = kinematics.solveFK(
        deg2rad(real_theta1), 
        deg2rad(real_theta2)
    );
    if (current_pos.y < 10.0f) {  // 虛擬圍籬
        Motor_Stop(&motor_joint_13pin);
        Motor_Stop(&motor_joint_8pin);
        return;
    }
    
    // === 步驟 D: 軌跡規劃 (產生速度與加速度) ===
    traj_joint1.update(target_angle1_deg, dt_seconds);
    traj_joint2.update(target_angle2_deg, dt_seconds);
    
    float target_vel1 = traj_joint1.getVelocity();      // Deg/s
    float target_acc1 = traj_joint1.getAcceleration(); // Deg/s²
    float target_vel2 = traj_joint2.getVelocity();
    float target_acc2 = traj_joint2.getAcceleration();
    
    // === 步驟 E: PID+前饋控制 ===
    Motor_Start(&motor_joint_13pin);
    Motor_Start(&motor_joint_8pin);
    
    float cmd_rpm1 = joint1_pid.update(
        target_angle1_deg,  // 目標位置
        target_vel1,        // 目標速度 (前饋)
        target_acc1,        // 目標加速度 (前饋)
        real_theta1,        // 當前位置 (反饋)
        dt_seconds          // 時間間隔
    );
    
    float cmd_rpm2 = joint2_pid.update(
        target_angle2_deg, target_vel2, target_acc2, 
        real_theta2, dt_seconds
    );
    
    // === 步驟 F: 輸出到馬達驅動層 ===
    Motor_SetSpeed(&motor_joint_13pin, (int32_t)cmd_rpm1);
    Motor_SetSpeed(&motor_joint_8pin, (int32_t)cmd_rpm2);
}
```

### 調用時序圖
```
時間: t=0ms → t=10ms → t=20ms → t=30ms ...
      ↓         ↓         ↓         ↓
   [ 編碼器讀取 ]
      ↓         ↓         ↓         ↓
   [   IK計算   ]
      ↓         ↓         ↓         ↓
   [ 軌跡規劃器 ] ← 產生速度/加速度前饋
      ↓         ↓         ↓         ↓
   [ PID更新    ] ← 結合反饋+前饋
      ↓         ↓         ↓         ↓
   [ 馬達輸出   ]
```

---

# 5. 馬達驅動層

## 5.1 核心函數 API
**檔案位置**: `Core/Src/nidec_motor_driver.c`

```c
// 初始化馬達系統
void Motor_System_Config(void);

// 更新編碼器讀數 (每個控制週期必調用)
void Motor_Update(Motor_t *motor);

// 讀取當前角度 (考慮減速比和編碼器 PPR)
float Motor_GetAngle(Motor_t *motor);

// 設定目標轉速 (RPM)
void Motor_SetSpeed(Motor_t *motor, int32_t rpm);

// 啟動/停止馬達
void Motor_Start(Motor_t *motor);
void Motor_Stop(Motor_t *motor);

// 重置編碼器計數
void Motor_ResetEncoder(Motor_t *motor);
```

---

## 5.2 馬達配置參數

```c
// 13-Pin 馬達 (24H702U030)
motor_joint_13pin.config.encoder_ppr = 100.0f;   // 編碼器線數
motor_joint_13pin.config.gear_ratio = 50.0f;     // 減速比
motor_joint_13pin.config.max_rpm = 6000;
motor_joint_13pin.config.htim_pwm = &htim2;      // PWM Timer
motor_joint_13pin.config.htim_encoder = &htim4;  // Encoder Timer

// 8-Pin 馬達 (24H220Q231)
motor_joint_8pin.config.encoder_ppr = 100.0f;
motor_joint_8pin.config.gear_ratio = 30.0f;
motor_joint_8pin.config.max_rpm = 6300;
motor_joint_8pin.config.htim_pwm = &htim3;
motor_joint_8pin.config.htim_encoder = &htim1;
```

---

## 5.3 角度計算公式

```c
// STM32 Encoder Mode 為 x4 模式 (上升沿+下降沿雙計數)
pulses_per_motor_rev = encoder_ppr * 4.0f;

// 輸出軸角度 = (總脈衝數) / (每圈脈衝數 * 減速比) * 360°
output_angle = (total_pulse_count) / (pulses_per_motor_rev * gear_ratio) * 360.0f;
```

### 範例計算
- **13-Pin 馬達**: 減速比 50:1，編碼器 100 PPR
  - 馬達轉一圈 = 100 × 4 = 400 脈衝
  - 輸出軸轉一圈 = 400 × 50 = **20,000 脈衝**
  - 解析度 = 360° / 20,000 = **0.018° per pulse**

---

## 5.4 編碼器溢位處理

```c
void Motor_Update(Motor_t *motor) {
    uint32_t current_cnt = __HAL_TIM_GET_COUNTER(motor->config.htim_encoder);
    uint32_t period = __HAL_TIM_GET_AUTORELOAD(motor->config.htim_encoder);
    
    // 計算與上次的變化量
    int32_t delta = (int32_t)current_cnt - (int32_t)motor->last_counter_val;
    
    // 處理溢位 (Overflow/Underflow)
    if (delta > (int32_t)(period / 2)) {
        delta -= (period + 1);  // 下溢
    } else if (delta < -(int32_t)(period / 2)) {
        delta += (period + 1);  // 上溢
    }
    
    motor->total_pulse_count += delta;
    motor->last_counter_val = current_cnt;
}
```

---

# 6. 參數調整指南

## 6.1 前饋參數調整步驟

### 第一階段: 純 PID 調整 (不使用前饋)
```cpp
// 將前饋增益設為 0
PositionController joint1_pid(5.0f, 0.1f, 0.0f, 0.0f, 0.0f, 3000.0f);
//                                              ↑Kv   ↑Ka
```
1. 調整 Kp 直到系統能跟隨目標 (可能有震盪)
2. 增加 Kd 以減少震盪
3. 加入小量 Ki 消除穩態誤差

### 第二階段: 加入速度前饋
```cpp
// 從 Kv=0.5 開始逐步增加到 1.0
PositionController joint1_pid(5.0f, 0.1f, 0.0f, 1.0f, 0.0f, 3000.0f);
```
- **現象**: 跟隨速度變快，延遲減少
- **調整**: 如果超調增加，略減 Kv 至 0.8~0.9

### 第三階段: 加入加速度前饋
```cpp
// 從 Ka=0.05 開始，逐步增加
PositionController joint1_pid(5.0f, 0.1f, 0.0f, 1.0f, 0.1f, 3000.0f);
```
- **現象**: 加速段響應更快，跟隨誤差減小
- **警告**: Ka 過大會造成啟動時抖動

---

## 6.2 推薦參數組合

| 負載情況 | Kp | Ki | Kd | Kv | Ka | 說明 |
|---------|----|----|----|----|----|----|
| 輕負載 (無末端工具) | 5.0 | 0.1 | 0.2 | 1.0 | 0.05 | 低慣量，快速響應 |
| 中負載 (夾爪) | 8.0 | 0.2 | 0.5 | 1.0 | 0.15 | 平衡性能 |
| 重負載 (重物) | 12.0 | 0.3 | 1.0 | 0.9 | 0.25 | 高增益補償 |

---

## 6.3 性能指標對比

| 指標 | 純 PID | PID + 速度前饋 | PID + 速度 + 加速度前饋 |
|------|--------|----------------|------------------------|
| 跟隨延遲 | ~100ms | ~30ms | ~10ms ⚡ |
| 穩態誤差 | ±2° | ±1° | ±0.5° ✨ |
| 超調量 | 10% | 5% | 3% 📉 |
| 震盪衰減時間 | 500ms | 300ms | 150ms |

---

# 7. 故障排除

## 7.1 系統震盪 (Oscillation)
**症狀**: 馬達在目標位置附近來回抖動

**可能原因與解決方法**:
1. ❌ Kp 過大 → ✅ 降低 Kp
2. ❌ Kv 過大 → ✅ 降低到 0.8
3. ❌ 濾波器 alpha 過大 → ✅ 降低到 0.5
4. ❌ 機械間隙過大 → ✅ 檢查機械結構

---

## 7.2 響應遲緩 (Slow Response)
**症狀**: 馬達跟不上目標位置變化

**可能原因與解決方法**:
1. ❌ Kp 太小 → ✅ 增加 Kp
2. ❌ 缺少前饋 → ✅ 啟用 Kv (設為 1.0)
3. ❌ max_velocity 設定過低 → ✅ 放寬限制
4. ❌ 馬達供電不足 → ✅ 檢查電源供應

---

## 7.3 穩態誤差 (Steady-State Error)
**症狀**: 停止後與目標位置有固定偏差

**可能原因與解決方法**:
1. ❌ Ki = 0 → ✅ 增加 Ki 到 0.1~0.2
2. ❌ 減速比設定錯誤 → ✅ 檢查 `gear_ratio` 參數
3. ❌ 編碼器方向錯誤 → ✅ 檢查 A/B 相接線
4. ❌ 摩擦力過大 → ✅ 增加潤滑或調整 Ki

---

## 7.4 啟動衝擊 (Startup Jerk)
**症狀**: 開機或改變目標時有突然的劇烈動作

**可能原因與解決方法**:
1. ❌ Ka 過大 → ✅ 降低 Ka
2. ❌ 濾波器 alpha 過大 → ✅ 降低到 0.5
3. ❌ max_acceleration 過大 → ✅ 降低限制
4. ❌ 初始位置未歸零 → ✅ 開機時執行歸零程序

---

## 7.5 編碼器讀數異常
**症狀**: 角度跳變或不增加

**可能原因與解決方法**:
1. ❌ 編碼器線路接觸不良 → ✅ 檢查接線
2. ❌ Timer 未啟動 → ✅ 確認 `HAL_TIM_Encoder_Start()` 被調用
3. ❌ 編碼器 PPR 設定錯誤 → ✅ 檢查 `encoder_ppr` 參數
4. ❌ 減速比設定錯誤 → ✅ 檢查 `gear_ratio` 參數

---

# 8. 安全與注意事項

## 8.1 硬體連接注意事項

### ⚠️ 電源供應
- 馬達電源與邏輯電源**必須分離**
- 共地連接 (Common Ground)
- 建議使用獨立的馬達驅動電源供應器
- 電源容量需足夠（至少 5A 以上）

### ⚠️ 編碼器方向
- 安裝時需確認編碼器 A/B 相位與馬達旋轉方向的對應關係
- 如果方向相反，會導致正回饋（系統失控）
- 測試時先單獨檢查每個編碼器的計數方向

### ⚠️ 減速比設定
- 代碼中的減速比 (50:1, 30:1) 為範例值
- **必須依實際減速機規格修改**
- 錯誤的減速比會導致位置計算錯誤

### ⚠️ PWM 頻率
- TIM2/TIM3 的基礎頻率需設定適當
- 13-Pin 馬達需支援動態頻率變化 (100Hz ~ 10kHz)
- 8-Pin 馬達建議使用 20kHz PWM 頻率

---

## 8.2 軟體安全機制

### ✅ 虛擬圍籬 (Virtual Fence)
```cpp
if (current_pos.y < 10.0f && ik_mode_enabled) {
    Motor_Stop(&motor_joint_13pin);
    Motor_Stop(&motor_joint_8pin);
    return;
}
```

### ✅ 速度限制
- PID 控制器內建最大轉速限制
- 軌跡規劃器內建速度與加速度限制

### ✅ 緊急停止
- 可使用板載按鈕 PC13 作為緊急停止開關
- 建議在中斷服務程式中立即停止所有馬達

### ⚙️ 建議新增功能
- [ ] 軟體限位保護 (Angle Limits)
- [ ] 過流檢測與保護
- [ ] 看門狗定時器 (Watchdog)
- [ ] 故障狀態記錄

---

## 8.3 操作安全規範

1. 🚨 **首次啟動前**:
   - 確認機械結構在安全位置
   - 檢查所有線路連接
   - 準備好緊急停止按鈕

2. 🚨 **測試階段**:
   - 先使用測試模式驗證各馬達單獨運作
   - 逐步增加 PID 參數，不要一次設定過大
   - 保持安全距離，隨時準備按下緊急停止

3. 🚨 **日常使用**:
   - 開機後先執行歸零程序
   - 避免在工作空間邊界附近操作
   - 定期檢查機械結構的磨損情況

---

# 9. 待實作功能

## 9.1 高優先級
- [ ] **歸零程序** (Homing Routine)
  - 使用限位開關或電流檢測
  - 自動建立原點座標系

- [ ] **軟體限位** (Software Limit)
  - 關節角度範圍限制
  - 工作空間邊界檢查

- [ ] **緊急停止中斷**
  - 按鈕觸發立即停止
  - 安全狀態機制

## 9.2 中優先級
- [ ] **進階軌跡規劃**
  - 五次多項式軌跡 (Quintic Polynomial)
  - S 曲線加減速 (S-Curve)
  - 最短時間軌跡優化

- [ ] **示教模式** (Teaching Mode)
  - 手動拖動記錄路徑
  - 軌跡回放功能

- [ ] **碰撞檢測** (Collision Detection)
  - 電流監控
  - 力矩估算

## 9.3 低優先級
- [ ] **通訊協定**
  - USB CDC 虛擬串口
  - 指令解析器
  - 即時數據回傳

- [ ] **參數儲存**
  - Flash 非揮發性儲存
  - PID 參數線上調整
  - 配置檔管理

- [ ] **自適應控制**
  - 在線參數估計
  - 負載自適應

---

# 10. 參考資料

## 10.1 官方文件
- [STM32F446RE Datasheet](https://www.st.com/resource/en/datasheet/stm32f446re.pdf)
- [STM32 HAL Library Documentation](https://www.st.com/resource/en/user_manual/um1725-description-of-stm32f4-hal-and-lowlayer-drivers-stmicroelectronics.pdf)
- Nidec 24H702U030 規格書
- Nidec 24H220Q231 規格書

## 10.2 理論基礎
- 五連桿機構運動學理論
- PID 控制理論
- 前饋控制 (Feedforward Control)
- 軌跡規劃 (Trajectory Planning)

## 10.3 開發工具
- STM32CubeIDE
- STM32CubeMX (硬體配置工具)
- VS Code + Copilot (代碼編輯)

---

# 附錄 A: 常用公式速查

## A.1 單位轉換
```
角度 (Degree) ←→ 弧度 (Radian)
  rad = deg × π / 180
  deg = rad × 180 / π

角速度 (Deg/s) ←→ 轉速 (RPM)
  RPM = (Deg/s) / 6.0
  Deg/s = RPM × 6.0
```

## A.2 編碼器計算
```
脈衝數 → 輸出軸角度:
  angle = (pulses / (PPR × 4 × gear_ratio)) × 360°

編碼器解析度:
  resolution = 360° / (PPR × 4 × gear_ratio)
```

## A.3 PWM 計算
```
13-Pin 馬達 (頻率控制):
  freq_hz = RPM × 400 / 60
  ARR = (Timer_Clock / freq_hz) - 1
  CCR = ARR / 2  (50% duty)

8-Pin 馬達 (佔空比控制, Low Active):
  CCR = ARR × (1 - speed_ratio)
  speed_ratio = current_rpm / max_rpm
```

---

# 附錄 B: 調試技巧

## B.1 UART 調試輸出
```c
// 在 main.c 中加入
#include <stdio.h>

// 重定向 printf 到 UART2
int _write(int file, char *ptr, int len) {
    HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);
    return len;
}

// 在 Robot_Loop 中輸出調試信息
printf("Angle1: %.2f, Angle2: %.2f, RPM1: %d\r\n", 
       real_theta1, real_theta2, cmd_rpm1);
```

## B.2 SWO 即時追蹤
- 在 STM32CubeIDE 中啟用 SWV (Serial Wire Viewer)
- 使用 `ITM_SendChar()` 輸出高速數據
- 適合高頻率數據監控（>1kHz）

## B.3 單元測試流程
1. **步驟 1**: 測試編碼器讀數
   - 手動旋轉馬達，觀察角度變化
   - 驗證方向正確性

2. **步驟 2**: 測試馬達速度控制
   - 使用測試模式 (`Robot_SetTestMode(true)`)
   - 單獨設定每個馬達的 RPM
   - 確認方向與速度正確

3. **步驟 3**: 測試 PID 控制
   - 設定固定目標角度
   - 觀察收斂速度與穩態誤差

4. **步驟 4**: 測試運動學
   - 給定簡單座標（如原點、遠端點）
   - 驗證 IK/FK 計算正確性

---

# 版本紀錄

| 版本 | 日期 | 變更內容 | 作者 |
|------|------|----------|------|
| v1.0 | 2025-12-30 | 初版：純 PID 控制 + 基礎運動學 | GitHub Copilot |
| v2.0 | 2025-12-31 | 加入前饋控制與軌跡規劃器<br>整合 Pinout 文檔與控制架構文檔 | GitHub Copilot |

---

**文檔維護者**: GitHub Copilot  
**最後更新**: 2025-12-31  
**聯絡方式**: 請透過專案儲存庫提交 Issue

---

*本文檔整合自 `Pinout_configuration.md` 與 `PID_Feedforward_Control_Architecture.md`*
