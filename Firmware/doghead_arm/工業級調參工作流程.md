# 工業級 PID 調參完整工作流程

## 📋 概述

本文檔說明如何使用**系統化、量化**的方法進行 PID 調參，而非手動觀察。

---

## 🎯 核心理念

### **傳統方法（低效）**
```
手動設定參數 → 觀察硬體動作 → 憑感覺調整 → 重複
❌ 主觀、無法量化、效率低
```

### **工業方法（高效）**
```
自動化測試 → 量化評估 → 數據分析 → 優化決策 → 重複
✅ 客觀、可量化、可重現、效率高
```

---

## 🔧 **完整工作流程**

### **階段 1：設定基準測試**

#### Step 1-1: 使用 STM32 端自動化測試
```c
// 在 main.c 中調用
#include "pid_tuning_assistant.c"

int main(void) {
    // ... 初始化代碼 ...
    Robot_Init();
    
    printf("按下用戶按鈕開始測試...\r\n");
    while (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET);
    
    // 執行完整測試
    Run_Comprehensive_Tuning_Test();
    
    // 或選擇單項測試
    // Auto_Test_StepResponse(&motor_joint_13pin, 30.0f, 5000);
    
    while(1);
}
```

#### Step 1-2: 透過串口接收數據
使用任何串口工具（如 PuTTY, TeraTerm, CoolTerm）：
- 波特率: 115200
- 數據格式: 8N1
- 將輸出保存為 `test_data.csv`

**輸出範例**：
```csv
Time_ms,Target_deg,Actual_deg,Error_deg,Control_RPM,Velocity_RPM
0,0.00,0.00,0.00,0.00,0.00
10,30.00,0.50,29.50,1475.00,25.30
20,30.00,2.30,27.70,1385.00,85.60
...
```

---

### **階段 2：離線數據分析**

#### Step 2-1: 使用 Python 分析數據
```bash
# 安裝必要套件
pip install numpy matplotlib scipy pandas

# 執行分析
python pid_analysis.py test_data.csv
```

#### Step 2-2: 查看性能指標
自動輸出：
- ✅ **總覽圖**：位置跟隨、誤差、控制輸出、速度
- ✅ **性能指標**：IAE, ISE, ITAE, 超調量, 穩定時間
- ✅ **頻譜分析**：震盪頻率檢測
- ✅ **綜合評分**：0-100 分

---

### **階段 3：參數優化決策**

根據性能指標調整參數：

#### 決策樹

```
【問題 1】系統是否穩定？
├─ ❌ 不穩定/震盪
│   ├─ 檢查頻譜分析 → 高頻震盪 (>1Hz)
│   │   └─ 解決：降低 Kp，增加 Kd
│   └─ 檢查頻譜分析 → 低頻震盪 (<1Hz)
│       └─ 解決：降低 Ki
│
└─ ✅ 穩定
    │
    【問題 2】穩態誤差是否可接受？
    ├─ ❌ 穩態誤差 > 2°
    │   └─ 解決：增加 Ki
    │
    └─ ✅ 穩態誤差 < 2°
        │
        【問題 3】響應速度是否滿意？
        ├─ ❌ 上升時間 > 500ms
        │   └─ 解決：增加 Kp，加入 Kv
        │
        └─ ✅ 上升時間滿意
            │
            【問題 4】運動中跟隨誤差？
            ├─ ❌ 運動中誤差 > 5°
            │   └─ 解決：調整 Kv (0.9~1.1)
            │
            └─ ✅ 跟隨良好
                │
                【問題 5】加速段跟隨誤差？
                ├─ ❌ 加速時明顯落後
                │   └─ 解決：增加 Ka
                │
                └─ ✅ 完美！
```

---

### **階段 4：參數掃描（可選）**

如果手動調整仍困難，使用自動掃描：

#### 方法 A：STM32 端自動掃描
```c
// 在 main.c 中
Scan_Kp_Parameter(&motor_joint_13pin, 1.0f, 20.0f, 10);
// 將掃描 Kp = 1, 3, 5, 7, 9, 11, 13, 15, 17, 20
// 自動輸出每組參數的性能指標
```

#### 方法 B：Python 批量分析
```python
# 假設您測試了多組參數並保存了數據
files = [
    'test_kp5_ki01.csv',
    'test_kp8_ki02.csv',
    'test_kp10_ki03.csv'
]
labels = ['Kp=5, Ki=0.1', 'Kp=8, Ki=0.2', 'Kp=10, Ki=0.3']

batch_analyze(files, labels)
# 自動生成對比圖和性能表
```

---

## 📊 **性能指標解讀**

### **1. IAE (Integral of Absolute Error)**
```
公式: ∫|error(t)| dt
意義: 總誤差累積量
目標: 越小越好
典型值: < 50 為優秀, < 100 為良好
```

**調整建議**：
- IAE 過大 → 增加 Kp 或加入前饋 (Kv)

### **2. ISE (Integral of Squared Error)**
```
公式: ∫error²(t) dt
意義: 懲罰大誤差
目標: 越小越好
```

**調整建議**：
- ISE 過大但 IAE 可接受 → 有瞬間大誤差，增加 Kd

### **3. ITAE (Integral of Time-weighted Absolute Error)**
```
公式: ∫t·|error(t)| dt
意義: 重視長期誤差
目標: 越小越好
```

**調整建議**：
- ITAE 過大 → 穩態誤差問題，增加 Ki

### **4. 超調量 (Overshoot)**
```
公式: (峰值 - 穩態值) / 步距 × 100%
意義: 過沖程度
目標: < 10% 為優秀, < 20% 可接受
```

**調整建議**：
- 超調量 > 20% → 降低 Kp 或增加 Kd

### **5. 穩定時間 (Settling Time)**
```
定義: 誤差進入 ±2% 範圍後不再出來的時間
意義: 系統收斂速度
目標: < 1 秒為優秀
```

**調整建議**：
- 穩定時間過長 → 增加 Kd 或減少 Ki

---

## 🎓 **實戰範例**

### **範例 1：初始參數評估**

**測試條件**：
```
參數: Kp=5.0, Ki=0.1, Kd=0.0, Kv=0.0, Ka=0.0
測試: 30° 階躍響應, 5 秒
```

**測試結果**：
```
IAE  = 125.5
ISE  = 385.2
超調量 = 35.2%
穩定時間 = 2800 ms
評分: 45 / 100 (需改進)
```

**診斷**：
- ❌ IAE 偏高 → 響應慢
- ❌ 超調量過大 → 震盪嚴重
- ❌ 穩定時間長 → 阻尼不足

**調整策略**：
1. 增加 Kd 到 0.5 以減少超調
2. 保持 Kp 不變
3. 重新測試

---

### **範例 2：加入阻尼後**

**新參數**：
```
參數: Kp=5.0, Ki=0.1, Kd=0.5, Kv=0.0, Ka=0.0
```

**測試結果**：
```
IAE  = 85.3  (↓ 改善)
ISE  = 185.7 (↓ 改善)
超調量 = 12.5% (↓ 大幅改善)
穩定時間 = 1200 ms (↓ 改善)
評分: 72 / 100 (良好 ⭐⭐)
```

**診斷**：
- ✅ 超調量已控制
- ⚠️ 運動中跟隨誤差仍偏高

**調整策略**：
1. 加入速度前饋 Kv=1.0
2. 進行正弦跟隨測試

---

### **範例 3：加入前饋後**

**最終參數**：
```
參數: Kp=5.0, Ki=0.1, Kd=0.5, Kv=1.0, Ka=0.1
```

**測試結果**：
```
IAE  = 32.8  (↓ 大幅改善)
ISE  = 45.2  (↓ 大幅改善)
超調量 = 8.2%
穩定時間 = 800 ms
評分: 88 / 100 (優秀 ⭐⭐⭐)
```

**結論**：✅ 達到工業級性能標準

---

## 🛠️ **工具整合建議**

### **方案 A：最小設定（僅 STM32）**
```c
// 只使用內建評估功能
Run_Comprehensive_Tuning_Test();
// 直接在串口查看性能指標
```

### **方案 B：標準設定（STM32 + Python）**
```bash
# 1. STM32 執行測試並輸出 CSV
Run_Comprehensive_Tuning_Test();

# 2. 複製數據到電腦
# 3. Python 分析
python pid_analysis.py test_data.csv
```

### **方案 C：專業設定（實時監控）**
使用 MATLAB/Simulink 或 LabVIEW：
- 實時數據採集
- 即時繪圖
- 參數線上調整
- Bode 圖分析

---

## 📈 **進階技巧**

### **技巧 1：Bode 圖分析（頻域）**
```python
# 使用 scipy 計算頻率響應
from scipy import signal

# 假設系統傳遞函數
num = [Kp]
den = [1, Kd, Kp, Ki]
sys = signal.TransferFunction(num, den)

# 繪製 Bode 圖
w, mag, phase = signal.bode(sys)
```

### **技巧 2：根軌跡法**
找出穩定邊界：
```python
# 計算閉環極點
poles = np.roots(den)
print(f"系統極點: {poles}")
# 極點應在左半平面 (實部 < 0)
```

### **技巧 3：自適應調參（未來）**
```c
// 根據負載自動調整
if (estimated_load > 0.7f) {
    Kp *= 1.2;  // 重負載增加增益
    Ka *= 1.5;  // 增加慣量補償
}
```

---

## ✅ **調參完成檢查清單**

在部署到生產環境前，確認：

- [ ] **穩定性測試**
  - [ ] 所有測試情況下無震盪
  - [ ] 穩態誤差 < 2°
  
- [ ] **性能測試**
  - [ ] IAE < 50
  - [ ] 超調量 < 15%
  - [ ] 穩定時間 < 1.5 秒
  
- [ ] **魯棒性測試**
  - [ ] 輕負載、中負載、重負載都穩定
  - [ ] 快速運動、慢速運動都流暢
  - [ ] 極限位置不抖動
  
- [ ] **安全測試**
  - [ ] 緊急停止有效
  - [ ] 限位保護有效
  - [ ] 異常情況自動停機

---

## 🎯 **總結**

**工業級調參 vs 手動調參**

| 項目 | 手動觀察 | 工業方法 |
|-----|---------|---------|
| 評估方式 | 主觀感覺 | 量化指標 |
| 效率 | 低（數小時） | 高（數分鐘） |
| 可重現性 | 差 | 優 |
| 優化方向 | 模糊 | 明確 |
| 記錄追蹤 | 困難 | 自動 |

**建議工作流程**：
1. 用自動測試快速獲得數據（5分鐘）
2. 用 Python 分析找出問題（2分鐘）
3. 根據指標調整參數（1分鐘）
4. 重複直到達標（通常 3-5 次迭代）

**總時間**：從數小時縮短到 30 分鐘！

---

**下一步**：實際操作本工作流程，記錄您的調參過程和結果！
